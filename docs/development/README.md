# DeepTrader 開発ガイドライン

## 1. 開発環境

### 1.1 パッケージマネージャー

DeepTraderでは、**pnpm**をパッケージマネージャーとして使用します。pnpmはnpmより高速で、ディスク効率が良く、より一貫性のある依存関係解決を提供します。

```bash
# パッケージのインストール
pnpm install

# 開発サーバーの起動
pnpm dev

# ビルド
pnpm build

# テスト実行
pnpm test
```

### 1.2 必要条件

- Node.js 18.x以上
- pnpm 8.x以上
- Supabase アカウント
- 各種API キー (OpenAI, BitGet)

## 2. 開発フロー

DeepTraderプロジェクトでは、次の開発フローに従います：

1. 要件定義
2. テストケース作成
3. 実装
4. コードレビュー
5. テスト実行
6. マージ＆デプロイ

## 3. 開発方法論

### 3.1 テスト駆動開発 (TDD)

DeepTraderではTDDアプローチを採用します：

1. **テストの作成**: 機能を実装する前に、その機能のテストを作成します。
2. **実装**: テストが失敗することを確認した後、テストをパスするように機能を実装します。
3. **リファクタリング**: テストをパスしたら、コードをリファクタリングして改善します。

#### Jestによるテスト

DeepTraderでは、Jestをテストフレームワークとして使用します：

```bash
# 全てのテストを実行
pnpm test

# ウォッチモードでテスト実行（変更を監視）
pnpm test:watch

# カバレッジレポートを生成
pnpm test:coverage
```

テストファイルは `src/tests` ディレクトリに配置し、以下の命名規則に従います：

- ユニットテスト: `*.test.ts(x)`
- 統合テスト: `*.integration.test.ts(x)`
- E2Eテスト: `*.e2e.test.ts(x)`

テストの例：

```typescript
// src/tests/components/TradingChart.test.tsx
import { render, screen } from '@testing-library/react';
import TradingChart from '@/components/TradingChart';

describe('TradingChart', () => {
  it('正しくレンダリングされること', () => {
    render(<TradingChart symbol="BTC/USDT" timeframe="1h" />);
    expect(screen.getByTestId('trading-chart')).toBeInTheDocument();
  });

  it('時間枠が変更されたとき、チャートが更新されること', () => {
    // テスト実装
  });
});
```

### 3.2 ドメイン駆動設計 (DDD)

DDDの原則に従い、ビジネスドメインを中心にコードを構築します：

1. **ユビキタス言語**: プロジェクト全体で一貫した用語を使用します。
2. **境界付けられたコンテキスト**: 明確な境界を持つドメインモデルを作成します。
3. **エンティティ、値オブジェクト、集約**: 適切なドメインオブジェクトを使用します。
4. **リポジトリ**: データアクセスを抽象化します。

### 3.3 リファクタリング方針

既存機能の動作を保ったままコードを整理する際は、[docs/refactoring/README.md](../refactoring/README.md) を参照してください。

## 4. コーディング規約

### 4.1 TypeScript

- [TypeScript Style Guide](https://google.github.io/styleguide/tsguide.html)に従います。
- 厳格な型付けを使用し、`any`型の使用を避けます。
- インターフェースとタイプエイリアスを適切に使い分けます。

### 4.2 React / Next.js

- 関数コンポーネントとReact Hooksを使用します。
- App Routerを使用し、サーバーコンポーネントとクライアントコンポーネントを適切に分離します。
- コンポーネントは単一責任の原則に従います。

### 4.3 コードフォーマット

- Prettierを使用して一貫したコードフォーマットを維持します。
- `.prettierrc.js`ファイルで設定を共有します。

## 5. ディレクトリ構造

次のディレクトリ構造に従います：

```
/src                          # ソースコードのルート
  /app                        # Next.js App Router
  /components                 # UIコンポーネント
  /hooks                      # カスタムフック
  /lib                        # ユーティリティ関数
  /mastra                     # Mastra AIエージェント
    /agents                   # エージェント定義
    /tools                    # ツール定義
    /workflows                # ワークフロー
    /memory                   # メモリ管理
    /mcp                      # MCPサーバー/クライアント
  /domain                     # ドメインロジック
    /trading                  # トレーディングドメイン
    /market                   # 市場データドメイン
    /user                     # ユーザードメイン
  /infrastructure             # 外部サービス連携
  /types                      # 型定義
  /tests                      # テストファイル
```

## 6. Git ワークフロー

以下のGitワークフローに従います：

1. **ブランチ戦略**:

   - `main`: 本番用コード
   - `develop`: 開発用コード
   - `feature/*`: 新機能開発
   - `bugfix/*`: バグ修正

2. **コミットメッセージ規約**:

   ```
   [絵文字] [タイプ]: [変更内容の簡潔な説明]

   [詳細な説明（必要な場合）]
   ```

   例:

   - `🚀 feat: トレードエージェント機能の追加`
   - `🐛 fix: チャート更新時のメモリリーク修正`
   - `📝 docs: READMEの更新`

## 7. CI/CD

将来的には以下のCI/CDパイプラインを実装する予定です：

1. **継続的インテグレーション**:

   - コードのリント
   - テストの実行
   - タイプチェック

2. **継続的デリバリー**:
   - ステージング環境へのデプロイ
   - E2Eテスト
   - 本番環境へのデプロイ

## 8. ドキュメント

全ての主要なコンポーネント、機能、APIには適切なドキュメントを提供します：

- コードには適切なJSDocコメントを使用します。
- 複雑なロジックや非自明な決定には説明コメントを追加します。
- APIエンドポイントとデータ構造は明確に文書化します。

## 9. 品質保証

コードの品質を確保するために以下の手法を採用します：

- **自動テスト**: ユニットテスト、統合テスト、E2Eテスト
- **コードレビュー**: すべてのプルリクエストに対して
- **静的解析**: ESLint, TypeScriptによる型チェック
- **パフォーマンスモニタリング**: 実行時のパフォーマンス測定
- **アクセシビリティテスト**: UIコンポーネントのアクセシビリティ確認

## 10. バージョン管理

### 10.1 Git戦略

- **ブランチング戦略**: GitFlowを採用
  - `main`: 本番リリース用
  - `develop`: 開発用メインブランチ
  - `feature/*`: 新機能開発用
  - `bugfix/*`: バグ修正用
  - `release/*`: リリース準備用
  - `hotfix/*`: 緊急修正用

### 10.2 コミットメッセージ

コミットメッセージは以下の形式に従います：

```
<絵文字> <タイプ>: <タイトル>

<詳細な説明>
```

**タイプ**:

- `feat`: 新機能
- `fix`: バグ修正
- `docs`: ドキュメントのみの変更
- `style`: コードの意味に影響しない変更（空白、フォーマットなど）
- `refactor`: バグ修正や機能追加ではないコード変更
- `perf`: パフォーマンス向上のための変更
- `test`: テストの追加・修正
- `chore`: ビルドプロセスやツールに関する変更

**例**:

```
🚀 feat: チャートコンポーネントに時間枠切り替え機能を追加

- 1分、5分、15分、1時間、4時間、日、週、月の時間枠を選択可能
- 選択した時間枠に応じてデータが再取得される
- 時間枠がローカルストレージに保存される
```

### 10.3 プルリクエスト

- PRには明確な説明と、関連するチケット番号を含めます。
- コードレビューは少なくとも1人のレビュアーによって行われる必要があります。
- CIパイプラインのテストが全て成功していることを確認します。
- コードの品質基準を満たしていることを確認します。

## 11. 環境設定

### 11.1 開発環境

- **Node.js**: v18.x以上
- **pnpm 8.x以上**
- **VS Code** (推奨エディタ)
  - 推奨拡張機能:
    - ESLint
    - Prettier
    - TypeScript Error Translator
    - Tailwind CSS IntelliSense

### 11.2 環境変数

- `.env.local`ファイルを使用して環境変数を管理します。
- `.env.example`ファイルに必要な環境変数のテンプレートを提供します。
- 機密情報は`.env.local`に保存し、リポジトリにコミットしないでください。

## 12. ドキュメント

- 新しい機能を追加する際は、必要に応じてドキュメントを更新します。
- APIエンドポイントはSwagger/OpenAPIでドキュメント化します。
- アーキテクチャの決定は`docs/architecture`ディレクトリに記録します。
- 主要なコンポーネントには使用例とAPIドキュメントを提供します。

## 13. パフォーマンス考慮事項

- 大きなライブラリは部分的にインポートします。
- 画像は最適化して使用します。
- クライアントサイドのデータフェッチングではキャッシングを活用します。
- パフォーマンス上の問題が疑われる場合は、React DevTools Profilerを使用して分析します。

## 14. アクセシビリティ

- WAI-ARIA標準に従います。
- キーボードナビゲーションをサポートします。
- 十分なコントラスト比を確保します。
- スクリーンリーダー互換性を確保します。

## 15. デプロイメント

### 15.1 CI/CD

- GitHub Actionsを使用して自動テストとデプロイを行います。
- PRごとにテストとlintチェックを実行します。
- `develop`ブランチへのマージでステージング環境にデプロイします。
- `main`ブランチへのマージで本番環境にデプロイします。

### 15.2 環境

- **開発環境**: ローカル開発用
- **ステージング環境**: テスト用、Vercelプレビュー
- **本番環境**: エンドユーザー向け、VercelとSupabase

## 16. チャットUI例

以下はメッセージバブルとサイドバーを含むチャット画面の例です。

![Chat UI Example](../assets/chat-example.png)

サイドバー下部の「新しいチャット」ボタンを押すと、新規会話を開始できます。ボタンをクリックすると現在のメッセージ履歴がリセットされ、新しい会話が選択された状態になります。

メッセージは送信時刻とアバター付きで表示され、会話一覧と選択状態はブラウザの`localStorage`に保存されます。新しいメッセージが届くと表示領域が自動で最下部までスクロールし、エラー発生時にはトースト通知が表示されます。送信ボタンには`aria-label="送信"`が付与され、アクセシビリティも向上しました。
